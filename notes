HASH BLOCO BTC:
  bloco bitcoin citado na blaze:
    https://www.blockchain.com/btc/block/570132
    corresponde a esse hash:
      00000000000000000029519374cde7aec54985f1caf22d946f5841d65b21024f
  hash citada na blaze
    0000000000000000000415ebb64b0d51ccee0bb55826e43846e5bea777d91966
    corresponde a esse bloco:
      https://www.blockchain.com/btc/block/570128
        colocando a hash que corresponde ao bloco BTC 570128 gera o seguinte HMAC:
          a9888e01cb6d81cbed63161e9acfa6304ecd2ed8c48c6b0a18a83d741aabd5b4
            com o fator: 2.94
  Há divergência do que é citado no site pro que é encontrado na blockchain



SEED FINAL DA CADEIA PROBABLY FAIR:
  A seed final/terminal desta cadeia é
    492bd10144a3525e2745718fe4d25e08affbea483872d8e8b86191b20ce0a7a8
      fator: 1.29
  SE esta é uma extremidade da lista E diz que há 10 milhoes de interações
    ENTÃO obter as 10 milhões de linhas com colunas Factor,Seed,HMAC
      E selecionar uma seed atual procurando dentro das 10 milhoes obtidas
  2021-05-12_23:31:27
    Não deu certo



CONSOLE.LOG DA PÁGINA BLAZE:
  ao acessar a página:
  https://blaze.com/pt/games/crash
  console.log mostra isso:
  [Blaze.com] Client version: 396d4451, Server version: a4c4519a
  2021-05-13_20:42:45
    nenhuma idéia do que fazer com essa informação ainda



DATAFRAME 'data.pkl':
  gerado 10 milhões de linhas com seeds(hash sha256), hmacs(hash hmac) e points(getPoint(hmac))
    a partir da hash '492bd10144a3525e2745718fe4d25e08affbea483872d8e8b86191b20ce0a7a8'
  2021-05-13_11:47:14
    encontrado padrão nas 2 e 4 primeiras letras da hash HMAC listados por pontos de crash
      isso se repete em 'data2.pkl'


DATAFRAME 'data2.pkl':
  gerado 10 milhões de linhas com seeds(hash sha256), hmacs(hash hmac) e points(getPoint(hmac))
    a partir da última hash em "data.pkl"[seeds].iloc[-1]


COMEÇAR A JOGAR, FAZER dinheiro:
  prever a probabilidade do próximo factor em intervalos
    rapid crashes (less than 4s)
      0.00 a 1.00 instantly
      1.01 a 1.20 almost instantly
    humility crashes (4s for 12s)
      1.21 a 1.40 low profit
      1.41 a 1.70 medium profit
      1.71 a 2.00 nice profit
    ideal crashes (12s for 20s[VERIFICAR])
      2.01 a 2.20 low doubled
      2.21 a 2.50 medium doubled
      2.51 a 2.80 not triple
    greed crashes (VERIFICAR o tempo)
      2.81 a 3.00 almost triple
      3.01 a 3.20
    dream crashes
      3.21 a +0.19


DURAÇÃO DOS CRASHES DE ACORDO COM O FATOR:
  é um gráfico exponencial
    base aproximadamente = 1.0605404816140187
      na formula: base**segundos = fator
        descobrir segundos: log fator base = segundos
          python3: math.log(fator, base) >>> segundos(float)
          RESULTADO OK, mas pode haver variação de 200ms



SCRIPT real time probability:
x  open blaze
x  getpoint
x    save initial points quantity
x      timestamp of this
x    get last point hash
  estimate
x    generate from last hash point 1,000 past points
x      do not use list.append(x) (item to end), but use list.insert(0, x) (item to begin, first)
x    save to dataframe the list of points, seeds and hmacs

x    put in new dataframe just points
    CAUCULATE()
x      scroll through the entire list
x        get totals
x          quantity of items with points > 2.20
            min quantity points > 2.20
            max
            mean
            range
          sum of points / mean of points
          max point value
          min point value (generally 0 or 1.00 expected)
          
      scroll through the list every item with range hundred
        get these in columns from line 101 of dataframe
          quantity of items with points > 2.20
            min quantity points > 2.20
            max
x            mean
            range
          sum of points (mean of points)
          max point value
          min point value (generally 0 or 1.00 expected)

        next point[100] after this round is > 2.20
          conditions 2*2*2*3*3*3 = 216 combinations
            first point[0] that get out in next round is > 2.20
            last point[99] that get in in this round is > 2.20
            quant items > 2.20
              current (100) in % - total (10,000) in %
                < -5% = 0
                >= -5% & <= 5% = 1
                > 5% = 2
              mean % - total mean %
                < -5% = 0
                >= -5% & <= 5% = 1
                > 5% = 2
            mean current 100 points % - mean 10,000 total points %
              < -5% = 0
              >= -5% & <= 5% = 1
              > 5% = 2
        
        get a list of combinations that next point[100] > 2.20
          count ocurrencies
            sort from greater n ocurrencies to less n ocurrencies

        compare the last point hash combination with combinations list
          return if next point will be > 2.20

      turn back to blaze window
      init listener
        get points quantity again
        get difference between len(initial quantity) and len(atual quantity)
          if difference < 1:
            keep listener

          if difference > 1:
            use difference to keep the firsts
            take from the last to first:
              insert into dataframe (new line)
                CAUCULATE()
                create a new column that register if the SCRIPT was a coorect prevision
                  regiter correct or incorrect prevision to future count
              show probability of next
              keep listener
          else:
            take new item:
              insert into dataframe (new line)
                CAUCULATE()
                  regiter correct or incorrect prevision to future count
              show probability of next
              keep listener



